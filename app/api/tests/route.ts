import { NextRequest, NextResponse } from 'next/server';

// Типы для тестов
interface Question {
  question: string;
  options: string[];
  correct: number;
}

interface Test {
  id: number;
  title: string;
  questions: Question[];
}

// Моковые данные тестов (fallback)
const mockTests: Test[] = [
  {
    id: 1,
    title: "Промышленная робототехника (ДПО)",
    questions: [
      {
        question: "Какой параметр важен при настройке скорости движения робота при сварке?",
        options: [
          "Вид электрода",
          "Сила тока и скорость подачи проволоки",
          "Толщина защитного покрытия"
        ],
        correct: 1
      },
      {
        question: "Как называется процесс размещения продукции на поддонах с помощью робота?",
        options: [
          "Сортировка",
          "Упаковка",
          "Паллетирование"
        ],
        correct: 2
      },
      {
        question: "Какой тип движения робота обеспечивает точность при нанесении покрытия?",
        options: [
          "Дискретное",
          "Непрерывное с постоянной скоростью",
          "Пульсирующее"
        ],
        correct: 1
      },
      {
        question: "Какой датчик чаще всего используется для контроля толщины сварного шва?",
        options: [
          "Лазерный датчик",
          "Тепловизор",
          "Акустический датчик"
        ],
        correct: 0
      },
      {
        question: "Какое условие необходимо для точного паллетирования грузов?",
        options: [
          "Стабильность системы захвата",
          "Высокая скорость манипулятора",
          "Использование механических ограничителей"
        ],
        correct: 0
      },
      {
        question: "Какой основной фактор влияет на качество шва при сварке роботом?",
        options: [
          "Скорость подачи проволоки",
          "Цвет защитного газа",
          "Угол наклона робота"
        ],
        correct: 0
      },
      {
        question: "Какой параметр критически важен при настройке конвейерной системы для робота?",
        options: [
          "Освещенность рабочего пространства",
          "Скорость движения конвейера",
          "Температура окружающей среды"
        ],
        correct: 1
      },
      {
        question: "Какой тип роботов чаще всего используется для нанесения краски?",
        options: [
          "Шестизвенные манипуляторы",
          "Параллельные роботы",
          "Каркасные манипуляторы"
        ],
        correct: 0
      },
      {
        question: "В какой системе координат производится программирование движения промышленного робота?",
        options: [
          "Декартова система координат",
          "Полярная система координат",
          "Цилиндрическая система координат"
        ],
        correct: 0
      },
      {
        question: "Какой компонент роботизированной системы отвечает за контроль параметров движения?",
        options: [
          "Привод",
          "Контроллер",
          "Захват"
        ],
        correct: 1
      }
    ]
  },
  {
    id: 2,
    title: "Архитектор будущего: Нейросетевое искусство (ДПО)",
    questions: [
      {
        question: "Что является основным компонентом нейросетевого алгоритма?",
        options: [
          "Весовые коэффициенты",
          "Нейроны и связи между ними",
          "Алгоритмы сортировки"
        ],
        correct: 1
      },
      {
        question: "Как называется процесс обучения модели на размеченных данных?",
        options: [
          "Обучение с учителем",
          "Обучение без учителя",
          "Генетический алгоритм"
        ],
        correct: 0
      },
      {
        question: "Какой метод уменьшает размерность данных в машинном обучении?",
        options: [
          "Градиентный спуск",
          "PCA (анализ главных компонент)",
          "Метод опорных векторов"
        ],
        correct: 1
      },
      {
        question: "Какой тип нейронной сети используется для обработки изображений?",
        options: [
          "Сверточные нейронные сети (CNN)",
          "Рекуррентные нейронные сети (RNN)",
          "Генеративно-состязательные сети (GAN)"
        ],
        correct: 0
      },
      {
        question: "Какой термин обозначает способность модели обобщать знания?",
        options: [
          "Обобщающая способность",
          "Переобучение",
          "Деградация модели"
        ],
        correct: 0
      },
      {
        question: "Как называется метод, позволяющий обучать нейросеть без разметки данных?",
        options: [
          "Обучение без учителя",
          "Обучение с подкреплением",
          "Глубокое обучение"
        ],
        correct: 0
      },
      {
        question: "Какая функция активации часто используется в скрытых слоях нейросети?",
        options: [
          "ReLU (Выпрямленный линейный блок)",
          "Softmax",
          "Линейная функция"
        ],
        correct: 0
      },
      {
        question: "Какой инструмент помогает визуализировать процесс обучения модели?",
        options: [
          "Тензорная доска",
          "Юпитер",
          "Преуспеть"
        ],
        correct: 0
      },
      {
        question: "Какой алгоритм машинного обучения основан на деревьях решений?",
        options: [
          "Случайный Лес",
          "Градиентный спуск",
          "K-Означает"
        ],
        correct: 0
      },
      {
        question: "Какой метод часто используется для борьбы с переобучением?",
        options: [
          "Увеличение сложности модели",
          "Дроп-аут (dropout)",
          "Уменьшение данных"
        ],
        correct: 1
      }
    ]
  }
];

// Функция для загрузки тестов из внешнего источника (заглушка)
async function loadTestsFromExternalSource(): Promise<Test[] | null> {
  try {
    // Здесь можно добавить логику загрузки из базы данных или внешнего API
    // Например:
    // const response = await fetch('https://api.example.com/tests');
    // const tests = await response.json();
    // return tests;
    
    // Пока возвращаем null, чтобы использовать fallback
    return null;
  } catch (error) {
    console.error('Ошибка загрузки тестов:', error);
    return null;
  }
}

export async function GET(request: NextRequest) {
  try {
    const { searchParams } = new URL(request.url);
    const testId = searchParams.get('id');
    
    // Пытаемся загрузить тесты из внешнего источника
    let tests = await loadTestsFromExternalSource();
    
    // Если загрузка не удалась, используем моковые данные
    if (!tests) {
      tests = mockTests;
    }
    
    // Если запрашивается конкретный тест
    if (testId) {
      const test = tests.find(t => t.id === parseInt(testId));
      if (!test) {
        return NextResponse.json(
          { error: 'Тест не найден' },
          { status: 404 }
        );
      }
      return NextResponse.json(test);
    }
    
    // Возвращаем все тесты
    return NextResponse.json(tests);
    
  } catch (error) {
    console.error('Ошибка API тестов:', error);
    return NextResponse.json(
      { error: 'Внутренняя ошибка сервера' },
      { status: 500 }
    );
  }
}

// POST метод для создания/обновления тестов (опционально)
export async function POST(request: NextRequest) {
  try {
    const body = await request.json();
    
    // Здесь можно добавить логику сохранения теста
    // Например, в базу данных
    
    return NextResponse.json(
      { message: 'Тест успешно сохранен', id: body.id },
      { status: 201 }
    );
    
  } catch (error) {
    console.error('Ошибка сохранения теста:', error);
    return NextResponse.json(
      { error: 'Ошибка сохранения теста' },
      { status: 500 }
    );
  }
}